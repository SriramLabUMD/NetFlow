function [flow] = NetFlow(model,vRef)
%% Main function for NetFlow algorithm (Mack and Sriram, Met. Eng. Comm. 2021)
% Identifyies carbon flow and carbon yield between metabolites within a
% given metabolic model and flux map

% Inputs:
%   model - metabolic model with full carbon atom maping, carbon counts,
%   and reactant/product annotation (modified COBRA structure)
%       .AMM - cell vector of matrices with individual carbon atom mapping from each reactant
%       atom to each product atom for each carbon-containing reaction
%       (product atoms x reactant atoms)
%       .nCarbon - total carbon in each metabolite
%       .nCarbTot - total carbon exchanged in each reaction
%       .products/.reactants - cell vector containing the product/reactant
%       metabolite names for each reaction in the order they are mapped in the corresponding AMM
%       .prodIdx/.reactIdx - cell vector containing the product/reactant
%       indices (row in S) for each reaction in the order they are mapped in the corresponding AMM
%       .symMets (optional) - matrix with the mapping of all symmetric
%       metabolites (Column 1/3: symetric metabolite indices, column 2/4: symetric
%       atom indices)
%   
%   vRef - reference flux vector from which the carbon flow is to be isolated
%
% Output:
%   flow - structure containing the relational matrices generated by NetFlow
%       .metLinks - logical carbon connectivity matrix for every
%       carbon-containing metabolite in the network (L matrix from
%       Mack and Sriram)
%       .metYield - carbon yield matrix for every
%       carbon-containing metabolite in the network (EOL matrix from
%       Mack and Sriram)
%       .cYield - specific carbon yield matrix for every
%       carbon-containing metabolite in the network (Eq. 7 from
%       Mack and Sriram)
%       .prodEOL/.reactEOL - average extent of labeling of products/reactants in each
%       carbon-containing reaction following the iterative labeling each carbon metabolite (not yet utilized)
%       .isoFlux - 13C flux (.reactEOL*vRef) in each carbon-containing
%       reaction following the iterative labeling each carbon metabolite (not yet utilized)
%
% Created by Sean Mack 12/11/19
% Last Modified by Sean Mack 8/5/2020
%% Flip any negative fluxes
neg = find(vRef<0);
model.S(:,neg) = -1*model.S(:,neg);
vRef(neg) = -1*vRef(neg);
for j = 1:length(neg)
    model.AMM{neg(j)} = model.AMM{neg(j)}';
end
tmp = model.reactants(neg);
model.reactants(neg) = model.products(neg);
model.products(neg) = tmp;

tmp = model.reactIdx(neg);
model.reactIdx(neg) = model.prodIdx(neg);
model.prodIdx(neg) = tmp;

%% Generate order n cumomer arrays
intCarbRxns = cellfun(@(x) ~isempty(x),model.AMM);

[cumomers,c2mMap,totCumomers] = generateCumomers(model.mets,model.nCarbon,1);
G = c2mMap*model.S;
if isfield(model,'symMets') %checks if the model contains any symmetric metabolites
    [CMM] = generateCMM(model.AMM(intCarbRxns), cumomers, model.nCarbon, model.prodIdx(intCarbRxns), model.reactIdx(intCarbRxns),model.symMets);
else
    [CMM] = generateCMM(model.AMM(intCarbRxns), cumomers, model.nCarbon, model.prodIdx(intCarbRxns), model.reactIdx(intCarbRxns));
end
%% Find metabolites that feed reference metabolite
%ID set of active metabolites and cumomers
nzFlux = vRef~=0;
nzS = model.S(:,nzFlux);
nzMet = sum(abs(nzS),2)~=0;

%Iteratively label each active metabolite that contains C
cMet = model.nCarbon>0;
metSet = find(nzMet & cMet);
nMets = length(model.mets);
metYield = zeros(nMets,nMets);
cYield = zeros(nMets,nMets);
metLinks = false(nMets,nMets);
nRxns = length(model.rxns);
cRxn = model.nCarbTot>0;
[reactEOL,prodEOL,isoFlux] = deal(zeros(nMets,nRxns));
for i = 1:length(metSet)
    %Label metabolite
    impIdx = metSet(i);
    nC = model.nCarbon(impIdx);
    labeledAtoms = (1:nC); %U-13C
    [xImpCmer, wtIdx] = generateInputCDV(nC,labeledAtoms);
    
    %Solve O(1) SS cumomer balances
    [~,~,A,b,xSS,~,~,~] = solveCumomerBalances(cumomers, CMM, totCumomers, xImpCmer, impIdx, wtIdx, vRef, G, intCarbRxns);
    
    %Calculate metabolite links and yields
    ssEOL = zeros(nMets,1);
    nLabeledC = zeros(nMets,1);
    for j = 1:nMets
        tmp = logical(c2mMap(:,j));
        ssEOL(j,1) = mean(xSS(tmp));
        nLabeledC(j) = sum(xSS(tmp));
    end
    linkMet = find(ssEOL(:,1)>0); %linked metabolites
    metLinks(impIdx,linkMet) = true;
    metYield(impIdx,linkMet) = ssEOL(linkMet);
    cYield(impIdx,linkMet) = nLabeledC(linkMet)/nC;
    
    %Calculate isotope fluxes
    rEOL = xSS'*(G<0);
    pEOL = xSS'*(G>0);
    reactEOL(impIdx,cRxn) = rEOL(cRxn)./model.nCarbTot(cRxn)';
    prodEOL(impIdx,cRxn) = pEOL(cRxn)./model.nCarbTot(cRxn)';
    isoFlux(impIdx,cRxn) = reactEOL(impIdx,cRxn).*vRef(cRxn)';
end

%% Build results structure
flow.metLinks = metLinks;
flow.metYield = metYield;
flow.cYield = cYield;
flow.reactEOL = reactEOL;
flow.prodEOL = prodEOL;
flow.isoFlux = isoFlux;
end
function [cumomers,c2mMap,totCmers] = generateCumomers(mets,nCarbon,order)
%Generates list of cumomers and cumomer-to-metabolite map (c2mMap) of the given order from list of
%metabolites and the number of C atoms per metabolite

if nargin < 3
    order = 1;
end

m = length(mets);
nCmers = zeros(m,1);
[nCarbUnique,~,nCMap] = unique(nCarbon);
uniqueCumomers = cell(length(nCarbUnique),1);
for i = 1:length(nCarbUnique)
    if nCarbUnique(i)>=order
        uniqueCumomers{i,1} = nchoosek(1:nCarbUnique(i),order);
    end
end

cumomers = cell(m,1);
startIdx = 1; %starting row index
for i = 1:m
    nCmers(i,1) = size(uniqueCumomers{nCMap(i)},1);   
    cumomers{i,1} = [repmat(i,nCmers(i),1),uniqueCumomers{nCMap(i)}];
    if nCarbon(i)>=order    
        endIdx = startIdx + nCmers(i) - 1; %ending row index
        
        c2mMap(startIdx:endIdx,1) = (startIdx:endIdx);
        c2mMap(startIdx:endIdx,2) = i;
        c2mMap(startIdx:endIdx,3) = 1;
        
        startIdx = startIdx + nCmers(i); %starting row index for next met
    end
end
cumomers = vertcat(cumomers{:});
totCmers = sum(nCmers); %total number of nth order cumomers
c2mMap = sparse(c2mMap(:,1),c2mMap(:,2),c2mMap(:,3),totCmers,m);
end
function [xImpCmer, wtIdx, impIso] = generateInputCDV(nCarbon,labeledAtoms)
%% Generates the cumomer distribution vector (CDV) based on total number of carbon atoms and which atoms are 13C labeled
% TODO: Need to correct minor hard coding for large metabolites
% Generate input IDV(s)
if nargin == 2       
    nLabels = size(labeledAtoms,1);
    if length(labeledAtoms(1,:)) == nCarbon && nLabels == 1
        uniform = 1;
        if nCarbon <= 15
            uIdx = 2^nCarbon;
            impIDV = sparse(uIdx,1,1);
        end
    else
        impIDV = zeros(2^nCarbon,nLabels);
        impIso = decimalToBinaryVector(0:2^nCarbon-1,[],'LSBFirst');
        for i = 1:nLabels
            labelIso = false(1,nCarbon);
            labelIso(labeledAtoms{i}) = true;
            labelIdx = all(impIso(:,labelIso),2)&~any(impIso(:,~labelIso),2);
            impIDV(labelIdx,i) = 1;
        end
    end
else
    impIDV = eye(2^nCarbon,2^nCarbon);
    impIDV = impIDV(:,2:end);
    impIso = decimalToBinaryVector(0:2^nCarbon-1,[],'LSBFirst');
end  

%Convert imput isotopomer labeling to cumomer labeling
if uniform == 1
    if nCarbon <= 15 
        xImpCmer = ones(size(impIDV));
        wtIdx = zeros(size(impIDV));
        wtIdx(1:nCarbon) = 1;
    else
        xImpCmer = ones(nCarbon,1);
        wtIdx = ones(nCarbon,1);
    end
else
    [wtIdx,bin2wt] = sort(sum(impIso,2));
    T = 1;
    for j = 1:nCarbon
        T = [T,T;zeros(size(T)),T];
    end
    xImpCmer = T*impIDV;
    xImpCmer = xImpCmer(bin2wt,:);
end
end
function [CMM] = generateCMM(AMM,cumomers,nCarbon,products,reactants,symMets)
%Generate reaction-specific CMMs from reaction-specific AMMs

% Set up
nRxns = length(AMM);
CMM = cell(nRxns,1);
if nargin < 6
    symMets = zeros(1,4);
end

% Iterate over each reaction
for r = 1:nRxns
    %Identify product atoms
    nP = length(products{r});
    prodAtoms = [];
    nCarbP = zeros(1,nP);
    for i = 1:nP
        nCarbP(i) = nCarbon(products{r}(i));
        prodAtoms = [prodAtoms,1:nCarbP(i)];
    end
    
    %Identify reactant atoms
    nR = length(reactants{r});
    reactAtoms = [];
    nCarbR = zeros(1,nR);
    for i = 1:nR
        nCarbR(i) = nCarbon(reactants{r}(i));
        reactAtoms = [reactAtoms,1:nCarbR(i)];
    end
    
    if length(prodAtoms) ~= size(AMM{r},1) || length(reactAtoms) ~= size(AMM{r},2)
        warning('Size of products or reactants doesnt match AMM dims - r = %d \n',r)
    else
        %Find cumomer pairs
        [pCumomers,rCumomers] = findCumomerPairs(AMM{r},reactAtoms,reactants{r},nCarbR,prodAtoms,products{r},nCarbP);
        
        %Generate cumomer map 
        nCmers = length(pCumomers);
        cmmMap = [];
        for i = 1:nCmers
            if size(pCumomers{i},1) == 1
                pIdx = find(all(bsxfun(@eq,pCumomers{i}{1},cumomers),2));
                for j = 1:length(rCumomers{i})
                    rIdx = find(all(bsxfun(@eq,rCumomers{i}{j},cumomers),2));
                    symIdx = find(all(bsxfun(@eq,rCumomers{i}{j},symMets(:,1:2)),2));
                    if isempty(symIdx)
                        cmmMap = [cmmMap;pIdx,rIdx,1];
                    else
                        cmmMap = [cmmMap;pIdx,rIdx,0.5];
                        matchIdx = find(all(bsxfun(@eq,symMets(symIdx,3:4),cumomers),2));
                        cmmMap = [cmmMap;pIdx,matchIdx,0.5];
                    end
                end
            end
        end
        CMM{r} = cmmMap;
    end
end
end
function [pCumomers,rCumomers] = findCumomerPairs(AMM,reactAtoms,reactants,nCarbR,prodAtoms,products,nCarbP)
%Generates reactant cumomers from product cumomers using the atom
%mapping matrix (AMM)

%Set up
nCarbPtot = length(prodAtoms);
nCarbRtot = length(reactAtoms);
nProd = length(products);
nReact = length(reactants);

prodCmers = nchoosek(1:nCarbPtot,1);
nCmers = size(prodCmers,1);
prodIso = zeros(nCmers,nCarbPtot);
reactIso = zeros(nCmers,nCarbRtot);
reactCmers = zeros(nCmers,1);
pCumomers = cell(nCmers,1);
rCumomers = cell(nCmers,1);
for i = 1:nCmers
    %Generate reactant cumomers
    prodIso(i,prodCmers(i,:)) = 1;
    reactIso(i,:) = prodIso(i,:)*AMM;
    reactCmers(i,:) = find(reactIso(i,:));
    
    for k = 1:nProd
        tmp = logical((prodCmers(i,:) <= sum(nCarbP(1:k))) .* (prodCmers(i,:) > sum(nCarbP(1:k-1))));
        if any(tmp)
            pAtoms = prodAtoms(prodCmers(i,tmp));
            pCumomers{i} = [pCumomers{i};{[products(k),pAtoms]}];
        end  
    end
    
    for k = 1:nReact
        tmp = logical((reactCmers(i,:) <= sum(nCarbR(1:k))) .* (reactCmers(i,:) > sum(nCarbR(1:k-1))));
        if any(tmp)
            rAtoms = reactAtoms(reactCmers(i,tmp));
            rCumomers{i} = [rCumomers{i};{[reactants(k),rAtoms]}];
        end  
    end               
end
end
function [x,t,A,b,xSS,dxdt,arrayTime,solveTime] = solveCumomerBalances(cumomers, CMM, totCumomers, xImpCmer, impIdx, wtIdx, vRef, G, intCarbRxns, nTimePoints, verbose)
%% Generates cumomer balance arrays and solves cumomer balance for a given input cumomer. Can optionally solve either instationary or steady state balances
% Initialize
if nargin < 11
    verbose = 0;
end
if nargin < 10 || nTimePoints == 0
    SSonly = 1;
end

if ~SSonly
    tEnd = 1000;
    tSpan = (0:tEnd/(nTimePoints-1):tEnd);
    tLow = [0;tEnd];
end

% Solve cumomer balances
tic
if verbose
    fprintf('Generating A matrix and b vector...\n')
end
xImp = sparse(totCumomers,1);
idx = (cumomers(:,1) == impIdx);
xImp(idx) = xImpCmer(wtIdx == 1,1);

% Generate A(v) and b(v,xImp,xLow) arrays
[A,b] = generateBalanceArrays(CMM,totCumomers,vRef,xImp,G,intCarbRxns);

%Check if A is row-balanced
% if any(abs(sum(A,2))>1E-10)
%     error('A matrix is unbalanced\n')
% end

%Remove 'zero flux' cumomers from A and b
nzCmer = diag(A) ~= 0;
Anz = A(nzCmer,nzCmer);
bNZ = b(nzCmer);
nzCmerCt = sum(nzCmer);

arrayTime = toc;

if verbose
    fprintf('Solving cumomer ODEs...\n')
end

%Calculate/estimate SS labeling
xSS = zeros(totCumomers,1);
xSS(nzCmer) = -1*Anz\bNZ;

if ~SSonly
    bNZ = repmat(b(nzCmer,:),1,nTimePoints);
    x = zeros(nTimePoints,totCumomers);
    dxdt = zeros(totCumomers,nTimePoints);
    if nzCmerCt > 0
        PS = spdiags(ones(nzCmerCt,1)*100,0,nzCmerCt,nzCmerCt);
        x0 = zeros(nzCmerCt,1);
        [t,xNZ] = ode45(@(t,x) cmerODE(t,x,PS,Anz,bNZ',tSpan),tSpan,x0);
        x(:,nzCmer) = xNZ;
        
        dxdt(nzCmer,:) = PS\(Anz*xNZ'+bNZ);
    end
    dxdt = dxdt';
else
    t = 0;
    x = [];
    dxdt = [];
end

solveTime = toc-arrayTime;

if verbose
    fprintf('Total solver time: %4.2f min\n',sum(solveTime)/60)
end
end
function [A,b] = generateBalanceArrays(CMM,totCumomers,vRef,xImp,G,intCarbRxns)
%% Generate reaction-specific CMMs from reaction-specific AMMs
% Set up
nIntRxns = length(CMM);
b = sparse(totCumomers,1);
map = cell(nIntRxns,1);
vInt = vRef(intCarbRxns);
gInt = G(:,intCarbRxns);

% Form O(n) balance matrix A(v)
for r = 1:nIntRxns
    map{r} = CMM{r};
    [uProd,~,iU] = unique(map{r}(:,1));
    cnt = ones(size(map{r},1),1);
    if length(uProd) ~= size(map{r},1)
        for i = 1:length(uProd)
            idx = (iU == i);
            cnt(idx) = sum(idx);
        end
    end
    map{r}(:,3) = vInt(r)*gInt(map{r}(:,1),r)./cnt;
end
map = vertcat(map{:});
O = sparse(map(:,1),map(:,2),map(:,3),totCumomers,totCumomers);
consV = (G.*(G < 0))*vRef;
A = O + spdiags(consV,0,totCumomers,totCumomers);
imp = xImp>0;
A(imp,~imp) = 0;

% Form constant vector b(v,xImp,xLow)
impV = (G.*(G > 0))*vRef;
b = b + xImp .* impV;
end
